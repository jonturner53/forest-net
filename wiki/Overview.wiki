
= Introduction to Forest =

_Forest_ is an overlay network designed for applications that involve a large number of distributed components whose real-time status is of interest to a dynamically changing subset of the other components. The primary motivating application for Forest is that of large-scale virtual worlds, but this application shares common characteristics with a variety of others, including many in the emerging class of distributed cyber-physical systems. These applications all require high quality real-time communication services that can guarantee timely data delivery among a large set of distributed components. The core primitive in Forest is a tree-structured channel, called a _comtree_ that supports both unicast and multicast packet delivery. Applications use comtrees as private networks, that are logically isolated and can be dynamically provisioned to meet application requirements. Application endpoints subscribe to multicast groups within their comtree using a lightweight signaling mechanism that enables endpoints to join/leave multicast groups many times per second. This enables each component to obtain reports from many different sources and to rapidly switch among sources.

Forest is designed to support large-scale real-time applications in which distributed components issue periodic reports to inform interested recipients of their changing status. The set of reports of interest to each component may change dynamically and the network must provide non-stop data delivery within each session, even as the pattern of communication changes. In the virtual world application, components are typically servers managing user avatars that move about the virtual world. Servers issue periodic reports about the avatars they manage, allowing other servers to track their status. As avatars move, they interact with a changing set of other avatars, requiring that servers continuously adjust the set of reports they receive. In systems that support audio interaction, servers must also transmit audio packets from active speakers so that all user avatars within audio range (in the virtual world) can hear them.

Distributed cyber-physical systems have requirements for network services that are similar to the virtual world application. We can view such systems as a set of sensors, whose role is to measure and report on the values of external signals, and a set of controllers, whose role is to manage some external device or mechanism. Sensors issue periodic reports and controllers monitor reports from one or more sensors, to enable them to make appropriate control decisions. We require network services that enable sensors and controllers to communicate reliably, while allowing maximal flexibility in the specific communication pattern. Examples of such systems range from large-scale chemical plants to automated rail and highway systems, to smart power grids.
The central requirement that these applications share is the need for real-time status reports that are delivered in a timely and non-stop fashion, even as the pattern of communication changes. This implies that the resources needed to ensure timely delivery must be available to the application, regardless of the specific communication pattern.

Our approach to addressing this requirement is the _comtree_. A comtree can be viewed as a private network with provisioned capacity. Each comtree is structured as a tree, which allows it to efficiently support both unicast and multicast communication, and to be efficiently provisioned for non-stop data delivery. Multicast allows data to be delivered efficiently to an arbitrary number of recipients and frees senders of the need to maintain communication state for multiple receivers. The comtree supports a very lightweight subscription mechanism, allowing endpoints to rapidly join and leave multicast groups, as their need for information changes. Forest leverages and adapts a number of well-established concepts and mechanisms from the networking literature. The merit of the Forest architecture rests not on the novelty of the specific elements, but in the way these elements are combined to address the needs of our target application class.

== Comtrees in Forest ==

The central primitive supported by Forest is the comtree. While the network’s links will typically form a general graph, each comtree uses a subset of the links that forms a tree. Each application session using Forest is assigned its own comtree and all communication for the session takes place within it. Comtrees support both unicast and multicast packet forwarding and operate as independent logical networks. Comtrees are isolated from one another and they can be separately provisioned, ensuring that excessive traffic within one comtree cannot disrupt the flow of packets within another.

Each comtree has its own address space and routes packets independently of other comtrees. We exploit the tree topology to simplify routing. Unicast routing information is acquired dynamically as a by-product of packet forwarding, in a way that is similar to the learning mechanism used by Ethernet LANs. In the absence of specific routing information, a Forest router forwards a packet to all of a comtree’s incident links (except of course, for the link on which the packet was received). Packets forwarded in this way are marked with a flag requesting routing information for the addressed destination, which triggers a response containing the required information. The use of tree-structured channels makes it fairly easy to support highly dynamic multicast groups, as there is no need to select routes for each group. Of course, the configuration of a comtree for a session does require the selection of a subtree joining the required endpoints with sufficient capacity on each link. 

Comtrees are identified by a numerical identifier that is included in the header of every packet. Comtree ids are flat global identifiers and imply no semantic information. Endpoints may send packets using only comtree identifiers for which they have been configured. Network endpoints and routers are each assigned a unicast address for use within the comtree. These addresses implement a two level hierarchy to improve scalability. Specifically, each unicast address has a _zip code_ part that identifies a geographic region and an _local address_ part that identifies a particular endpoint within the zip code. A Forest router uses the zip code to reach routers in other zip codes and uses the local address part to reach components within its own zip code. All nodes in a comtree with the same zip code are required to form a subtree within the comtree topology. This limits the required routing state to one set of routes for “foreign zip codes” and another for the local zip code. Multicast is implemented using separate multicast addresses. Endpoints in a comtree may send packets to any multicast address, causing the network to deliver a copy to all subscribed endpoints. Endpoints in a comtree may subscribe to any of its multicast addresses, and the subscription protocol allows endpoints to change subscriptions for many addresses with a single packet.

== Scalable Multicast Routing ==
Since each session communicates over its own comtree, one way to implement multicast is simply to broadcast every multicast packet to every router on the comtree and let the routers deliver packets to their directly attached endpoints based on local subscriptions (see left panel of Figure 3). This has the advantage that each router need only keep track of the subscriptions for its attached endpoints, minimizing the required multicast routing state, minimizing the subscription processing overhead and ensuring rapid response to subscription requests. On the other hand, it does require that multicast packets be distributed to routers whose endpoints may have no interest in them.

An alternate approach is to define a central “core” router in the comtree and configure each router with a “pointer” telling it which of its incident links leads to the core (see center panel of Figure 3). In this approach, all multicast packets are sent to the core router, and subscription requests are also forwarded towards the core router, while adding multicast routing state at each router along the path to the core. This largely eliminates the excessive transmission of unwanted multicast packets, while still allowing efficient subscription processing. On the other hand, it can slow down the response to subscription requests and places a larger burden for handling multicast routing state on the core router.

We have chosen a more general approach that can be used to implement either of the above options, as well as various intermediate points. In particular, we allow each multicast session to define a “core subtree” consisting of a subset of its overlay routers (see right panel of Figure 3). Each router outside the core has a pointer telling it how to reach the core, and all multicast packets are sent towards the core and distributed to all the routers in the core (note that this can be done without any multicast-specific routing state). Subscriptions flow towards the core and need never propagate any further than the first core router. We note that a small core provides the most efficient use of bandwidth at the cost of higher subscription processing overhead and slower response to subscription requests. There is a variety of ways one might select which routers to include in the core. Perhaps the simplest is based on a specified maximum “distance” between an endpoint and its nearest core node; the distance metric can be a function of both hop count and link delay. The core can then be made as small as possible, consistent with this constraint, providing a bound on the response time to subscription requests. Alternatively, the core can be adjusted dynamically, based on the subscription volume at a node.

3.3. Capacity Provisioning of Comtrees
As discussed above, our target applications require timely data delivery to distributed components, regardless of the specific pattern of communication. Endpoints can issue reports to interested recipients using multicast, with each endpoint using a separate multicast address for each distinct information stream. Alternatively, a single multicast address may be used for related information from several different sources (and potentially, a dynamically changing set of sources), allowing interested recipients to receive related information from any of a number of sources, using a single subscription. The objective of capacity provisioning is to ensure that comtrees have the resources needed to ensure timely delivery of data, even as multicast sources and subscriptions change. In many of the cases of interest, we expect frequent changes, making it difficult to respond to these changes by re-provisioning.
Our solution to this problem is based on the observation that even while the detailed pattern of communication among a set of distributed endpoints is highly dynamic, the volume of traffic that must be distributed to different parts of a tree-structured channel can be bounded. This is based on the observation that for the target applications, endpoint sending rates are periodic, or have limited variability. While there is more variability in the amount of traffic that endpoints receive, here too there are limits imposed by both the application and the fact that servers are generally capable of processing application packets at only a limited rate. In the virtual worlds setting, [BH08] has demonstrated that because users can only attend to a small number of dynamic objects at a time, it is not necessary to distribute full-rate updates for all objects that are within a user’s “virtual field of vision”. This makes it possible to bound the rate at which a server receives state updates for user avatars. Even for real-time audio, a similar situation arises. When there are multiple speakers within a given user’s audio range, it’s important to bridge the loudest audio streams to give the user a realistic experience, but it is typically not necessary to bridge more than three or four separate streams, as the intelligibility of the individual speakers drops rapidly. Given this natural characteristic of our target application, we can specify a sending limit α(u) and receiving limit ω(u) for each endpoint u. Given such limits, we can provision all the links in a comtree, so that they have the capacity to support any traffic pattern that does not exceed the limits. It is up to the endpoints to decide on the appropriate limits and ensure that they are respected, but so long as they do, they can be assured that no packets will be discarded or unduly delayed due to insufficient network capacity. 
The problem of provisioning tree-structured channels with specified send/receive limits was studied in another context by Fingerhut in [FI94, FI97]. He showed that one can provision the bandwidth on a link from x to y as follows. First, let X be the set of endpoints on x’s side of the link and let α(X) be the sum of the send limits for endpoints in X. Similarly, let Y be the endpoints on y’s side of the link and let ω(Y) be the sum of the receive limits in Y. The bandwidth needed from x to y is then min{α(X), ω(Y)}. Moreover, one can compute the required link capacities for all links in the tree, using a single tree traversal requiring O(n) time, for a tree with n nodes. To account for the use of a multicast core that receives copies of all multicast packets, we need to make a small modification to this procedure. Specifically, if there are any core routers on y’s side of the link, the required bandwidth is α(X). Otherwise, the required bandwidth is min{α(X), ω(Y)}. If the links are provisioned in this way, then the comtree is guaranteed to have the capacity needed for any traffic pattern that does not exceed the specified send and receive limits.
We note that while provisioning comtrees in this way ensures that we can accommodate rapid changes in traffic among a fixed set of endpoints, it does not ensure that we can handle rapid changes to the set of endpoints in the comtree. While we plan to address this issue over the course of the proposed project, it’s important to note that changes in the set of endpoints occur at a much slower rate than changes in the set of multicasts that they subscribe to (we anticipate that endpoints might change their subscriptions several times a second, while we expect the “turnover” of a typical application session to be no more than about 10% in a five minute period). Moreover, the addition of a new endpoint will generally involve an admission control decision. There is no requirement that every request to join a session be granted. Indeed, such requests may well be rejected when there is insufficient capacity to handle them. Alternatively, the serving of such requests may reasonably be delayed for as much as 10 seconds, while new capacity is provisioned to accommodate them.
3.4.   Selecting a Comtree Topology
Configuring a comtree for a session requires selecting a subtree of the overlay network infrastructure that has enough capacity to support arbitrary communication patterns among network endpoints. This is a special case of the constraint-based network design problem studied in [FI94, FI97, DU99]. In general, this problem is NP-hard. However, when the solutions are constrained to be trees, we can find optimal or near-optimal solutions in the cases most relevant to comtree configuration [FI94]. In particular, if A is the sum of all the α() values and Z is the sum of all the ω() values, then for A=Z, the least-cost solution is a shortest path tree from some “central” vertex in the overlay network to all endpoints that are to be included in the comtree. Such a tree can be constructed by computing a shortest path tree for the entire network and pruning links not used to reach endpoints in the comtree. By trying all possible center nodes, we can find the optimal solution in O(mn + n log n) time, where m is the number of links in the overlay network infrastructure, and n is the number of nodes. If A<Z, shortest path trees are not optimal, but are guaranteed to have a cost no more than (1+Z/A)/2 times that of the least-cost tree. We note that shortest path trees can be computed very rapidly. Indeed, for overlay infrastructures with say 1000 sites and 10,000 inter-site links, the time needed to compute a shortest path tree on a commodity server is just a few milliseconds. We plan to explore methods for reducing the number of distinct trees that must be computed, such as limiting the selection of root nodes to those that are most geographically central.
The prior work provides a solid basis for comtree configuration, but leaves several issues to be addressed. First, while reference [FI94] shows that shortest path trees are within a constant factor of optimal when A<Z, it provides no information about how to obtain better trees in this case. We find that when A is much smaller than Z (a realistic case in our target applications), other trees can substantially out-perform shortest path trees. We illustrate this with results from a simple experiment, shown in Figure 4. For this experiment, we generated random trees over n (=25) points distributed uniformly over a 2×2 square centered at the origin. Trees were constructed, starting from the most central vertex in the tree and provisioned to determine the cost. We treated each point as a Forest router, with n attached endpoints, and each endpoint was assigned a send limit of 1 and a receive limit that varied from 1 to 24. The cost of each provisioned link was taken to be its provisioned capacity times its length. Each data point in the figure shows normalized average results from 50 independently generated random trees. We do not show error bars, but standard deviations were computed and were typically less than 10% of the mean values. Results for three different trees are shown: shortest path trees, minimum spanning trees and an intermediate tree constructed using a variant of Prim’s minimum spanning tree algorithm, with a bound on the maximum allowed “stretch” with respect to distances from the tree root; we show the results when the stretch is limited to 1.2 (note that constraining stretch to 1, yields shortest path trees, while allowing it to be unbounded, yields minimum spanning trees). The shortest path tree cost grows linearly with the receive limit, and is very close to the analytical bound. The minimum spanning tree provides the best results for large fanout, and the bounded stretch trees perform nearly as well. We conjecture that a hybrid strategy, which mimics the minimum spanning tree algorithm in the early stages, and the shortest path tree algorithm in later stages, will out-perform the “pure” strategies considered here.
The earlier work also does not address the use of a core subtree for multicast packets. Core subtrees are useful, because they can significantly reduce the amount of routing state needed to “locate” a multicast group. This can be particularly important for applications that use many small, dynamic, multicast groups. On the other hand, the use of a core does impose a network bandwidth cost. We studied how this cost changes with the size of the core, and compared to the cost of implementing multicast without a core. We again generated random trees over n points distributed uniformly over a 2x2 square centered at the origin. Trees were constructed using the variant of Prim’s algorithm mentioned earlier; for each case, several values of stretch were evaluated and the one that produced the least expensive tree for the given provisioning method was selected. The results appear in Figure 5. First, we note that when the core consists of just the “center” node of the comtree, the cost is essentially indistinguishable from the case where no core is used. When the neighbors of the center node are added to the core, there is some increase, but the difference becomes negligible for larger receive limits. Larger cores lead to higher cost, but the cost difference shrinks rapidly as the ratio of receive limits to send limits grows.
The prior work must also be extended to account for capacity limits in the underlying substrate. It is tempting to think one might incorporate capacity limits by checking capacity constraints as each new link is added to the tree. Unfortunately, our provisioning method for comtrees requires that we know the endpoints in a subtree before we can determine the capacity for the link at the root of the subtree. While we can find low cost trees in the presence of ample network capacity, we do not have a general method for the harder problem of finding an optimal or near-optimal tree when there is limited capacity available. Over the course of this research, we plan to explore two alternative approaches to this problem. The first adjusts link costs to reflect the amount of available capacity (link costs would grow as their available capacity shrinks). This would steer the tree construction algorithm away from links with insufficient capacity, reducing the likelihood of selecting a tree that cannot be adequately provisioned. The second approach is a two phase algorithm in which an initial tree is computed without considering capacity constraints and then adjusted in a bottom-up fashion to take those costs into account. In each step, a node whose link to its parent is under-provisioned would select a new parent in the shortest path tree, taking into consideration both capacity constraints and distance from the tree root.
It must also be noted that provisioning comtrees for large distributed applications may require periodic “re-provisioning” to accommodate changes in the set of endpoints (for example, as individual users enter and leave a virtual world). While an application is free to reject a request to add a new endpoint to a comtree, if the required resources are not available, we certainly prefer to minimize the need to reject user requests if we reasonably can. Re-provisioning allows an application to manage its resource needs by over-provisioning the network capacity by a small amount to handle changes over a limited time-frame. Whenever its spare capacity drops below some threshold, it can request that the comtree be re-provisioned to a higher level. This would be handled by allocating a new comtree that may differ from the existing comtree, but may share capacity with it where they have links in common. Once the new comtree is configured, the application can signal to its endpoints to shift traffic from the old comtree to the new one, before releasing the old one. This approach leaves it to the application to decide how to accommodate changes in the set of endpoints, while providing appropriate support within Forest for whatever strategy the application chooses to implement.
3.5. Additional components
A complete implementation of Forest requires a number of additional elements. We touch briefly on those elements here.
•	Routing protocol. To support comtree provisioning, a routing protocol is needed to distribute information about the available capacity of links and overlay routers. We propose to use a comtree for this purpose, with each router using a separate multicast address to transmit its state information, while a set of “aggregators” collects status reports from routers in separate geographic regions and distributes succinct summaries. We note that a Forest overlay is operated as a single administrative domain, so we are not concerned with inter-domain routing.
•	Signaling protocol for comtree configuration. The comtree signaling protocol is used to create comtrees and add/remove endpoints. The user that creates a comtree is designated as its “owner” and controls how it is provisioned and accessed by others. The management of comtrees is distributed among the overlay routers using distributed hash table techniques. The router responsible for a given comtree maintains a complete view of its topology and determines how the topology is extended to handle new endpoints. It reserves the resources it needs through a request/response interaction with the routers directly responsible for the required resources.
•	Access protocol. The access protocol is used to connect endpoints to a Forest overlay. The access router within the overlay is chosen to minimize the length of the access connection. Only registered users can connect a new endpoint, and user identity is verified using standard cryptographic techniques. Forest packets going between endpoints and access routers are encapsulated and carried in a “tunnel”. 


== Links ==

  * [ControlMessages Control Messages]