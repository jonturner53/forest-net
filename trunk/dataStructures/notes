Rethinking the structure

Option 1.

Maintain basic approach but use additional C++ mechanisms.
Certainly use numeric limits and static_cast. Also, use
member functions that return references to update data
structure values.

Reconsider classes that use constructor. Can eliminate
the need for multiple functions by making the constructors
explicit. That is, they can't be be used for implicit
type conversions. Verify this.

Reconsider the use of operators. For lists, drop &= and <<=.
Instead, use enq(), deq() or perhaps the C++ names.
Could use += and -= for enq and deq. No obvious advantage.
Look for more elegant way to handle initialization of
dynamic storage in class hierarchies.

Add iterators to graphs.

Re-work argument handling to make it more general and
to support named arguments. Maybe use the standard
argument processing code.

Consider adding mechanisms to add vertices to an existing
graph.

Consider IO format that does not require sizes up-front.
Need to decide on delimiter to mark the end of a data structure
that might contain multiple items. Maybe <graph> .. </graph>.
Or maybe <graph n=xx m=yy> where xx and yy allocate space,
but don't necessarily define graph size. To maintain basic
approach, for graphs, need method to read edge list that
stops when next char is not (. Could have method that
reads into std::list and can be told how many elements
to expect for each edge (2,3,4,5) with extra items 
defined as integers (or maybe any numeric).

Could make weighted graph a template, so it accepts weights
of different types. Could do same for flow graphs.

Could generalize IO format so that tag specifies use of
alpha format, number of extra fields per edge and possibly
their types. Or could read all numbers into doubles and
then let program set the format.

Re-work misc. Maybe, just make it a namespace.
Think about IO utilities that makes better use of streams.
Write pair of routines for converting between an IP address
in numeric form and a string.

What's good about maintaining current approach?
Makes implementations relatively transparent.
Does not require much sophistication with C++.
By building data structures around small integers
can retain identity of a specific vertex/edge in
multiple data structures.

More general approach assigns a label to vertices/nodes
and maintains this label in the data structure.
Pointers are then used to refer to objects in the data
structure (or iterators). Names are used for IO and
for establishing correspondences. Hard to make this
efficient.

Stick with use of small integers, but do a better job of
explaining this to students up front. Use of ints gives us
a convenient "handle" that can be used in several different
contexts. Also, easier to do range checking than if we
use general pointers.

Option 2. Use the standard libraries wherever possible.

Requires more sophisticated use of C++,
but current students mostly have these skills.
They also have some familiarity with at least the STL.

Can certainly use provided mechanisms for lists, vectors, etc.

Look at Boost library for graphs.

Beyond that, how do we build the more sophisticated data structures?
For binary search trees could use map interface, but our own
implementations.

Or, could just implement using the lower-level mechanisms.

So, partition can be implemented using a vector<int>.
Is there any real advantage to this, as opposed to the
array of ints? No range checks. Could relieve us of
some storage management concerns. Use the resize()
operation on the vector as needed. Still need to
keep track of sizes and still need to delete vectors.
Does this help with graph class hierarchy?
Currently, we have makeSpace and copyFrom methods
so that we can do these functions in different contexts.
Very clumsy. Can vectors help make this more elegant.
Constructors, assignment operator and input method all
need to do these things. And we need a local version
for the constructors to use and a version that goes
up the hierarchy.

Since vectors store the array separately, we could make
the vector part of the graph data structure, rather than
using a pointer to it. This would eliminate the need to
do any explicit copying. The assignment operator would
copy the vector and would take care of the storage.
Need to think about what this means for constructor.
Do we need an explicit resize operator?

Find new name for list with membership test;
kind of a list/set hybrid - mlist. Perhaps drop
the singly linked version.

What about generalizing the heap to support a comparison
operation? Allows us to support min, max or cyclic heaps.
Think about using the priority queue interface for a heap.

