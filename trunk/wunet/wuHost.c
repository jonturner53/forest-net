// usage:
//      wuHost myIpAdr rtrIpAdr myAdr repeatFlag delta finTime
//
// WuHost is a simple packet generator for a wunet host.
// MyIpAdr and rtrIpAdr are the IP addresses of the host itself
// and the wunet router it connects to. MyAdr is the wunet adress
// of the host. Delta is the minimum number of microseconds
// between successive packet transmissions.
// FinTime is the number of seconds that the host should run.
//
// The packets generated by wuHost are determined by a packet
// specification that is read from stdin. The input may include
// comment lines (which begin with '#'). Each non-blank, non-comment
// line specifies one packet in the form of a list of integer values
// separated by blanks. The first value on each line is a
// pause specification that indicates the number of microseconds
// to wait before sending the packet. This is ignored if it is
// less than delta. The next three values specify the packet's
// length (in bytes), its vnet number and destination wunet address.
// The remaining values on the line are interpreted as the values
// of successive payload words. If the number of specified values
// is not sufficient for the specified packet length, remaining
// payload words are zero-padded.
//
// A line with a negative number in the first field is treated
// as a repeat specification. If the value is -k, it goes back
// to the k-th previous non-comment line and continues from there. The
// number of repetitions is determined by the second value on
// the line containing the repeat specification. Repeat spec's
// can be combined and may be used to form nested loops. They
// can also be overlapped in more general ways, but the results
// are not likely to be useful.
//
// The first packet in the specification is typically just intended
// to initialize port number field of the wunet router's link table
// entry for the link to the given host. Consequently, it gets special
// treatment. Specifically, it is sent after a one second delay, and
// another one second delay is inserted after it is sent.
//
// If repeatFlag=0, wuHost sends each of the listed packets one time,
// inserting the specified pauses before each packet sent.
// If repeatFlag=1, it loops repeatedly through all but the first
// packet until finTime is reached.
//
// WuHost also receives incoming packets from its attached router.
// It saves the first 50 of these and writes them to stdout
// at the end of execution. This is provided as a simple debugging aid.

#include "stdinc.h"
#include "wunet.h"
#include "wuHost.h"

main(int argc, char *argv[]) {
	int mip0, mip1, mip2, mip3, rip0, rip1, rip2, rip3;
	ipa_t myIpAdr, rtrIpAdr; wuAdr_t myAdr;
	int repeatFlag, delta, finTime;

	if (argc != 7 ||
	    sscanf(argv[1],"%d.%d.%d.%d", &mip3, &mip2, &mip1, &mip0) != 4 ||
	    sscanf(argv[2],"%d.%d.%d.%d", &rip3, &rip2, &rip1, &rip0) != 4 ||
	    sscanf(argv[3],"%d.%d", &myAdr) != 1 ||
	    sscanf(argv[4],"%d", &repeatFlag) != 1 ||
	    sscanf(argv[5],"%d", &delta) != 1 ||
	    sscanf(argv[6],"%d", &finTime) != 1)
		fatal("usage: wuHost myIpAdr routerIpAdr myAdr repeatCnt delta finTime");

	 myIpAdr = ((mip3 & 0xff) << 24)  | ((mip2 & 0xff) << 16) |
	           ((mip1 & 0xff) <<  8)  |  (mip0 & 0xff);
	rtrIpAdr = ((rip3 & 0xff) << 24)  | ((rip2 & 0xff) << 16) |
	           ((rip1 & 0xff) <<  8)  |  (rip0 & 0xff);

	wuHost host(myIpAdr,rtrIpAdr,myAdr);
	if (!host.init()) fatal("wuHost:: initialization failure");
	host.run((repeatFlag ? true : false), delta, 1000000*finTime);
}


// Constructor for wuHost, allocates space and initializes private data
wuHost::wuHost(ipa_t mipa, ipa_t ripa, wuAdr_t mwa)
	      : myIpAdr(mipa) , rtrIpAdr(ripa), myAdr(mwa) {
	nPkts = 10000;
	ps = new pktStore(nPkts+1, nPkts+1);

	// initialize socket address structures
	bzero(&sa, sizeof(sa));
	sa.sin_family = AF_INET;
	sa.sin_port = 0; // let system select address
	sa.sin_addr.s_addr = htonl(myIpAdr);
	bzero(&dsa, sizeof(dsa));
	dsa.sin_family = AF_INET;
}

wuHost::~wuHost() { delete ps; }

bool wuHost::init() {
// Initialize IO. Return true on success, false on failure.
// Configure socket for non-blocking access, so that we don't
// block when there are no input packets available.
	// create datagram socket
	if ((sock = socket(AF_INET, SOCK_DGRAM, 0)) < 0) {
                return false;
        }
	// bind it to the socket address structure
        if (bind(sock, (struct sockaddr *) &sa, sizeof(sa)) < 0) {
                return false;
        }
	// make socket nonblocking
	int flags;
	if ((flags = fcntl(sock, F_GETFL, 0)) < 0)
		return false;
	flags |= O_NONBLOCK;
	if ((flags = fcntl(sock, F_SETFL, flags)) < 0)
		return false;
	return true;
}

bool wuHost::getPacket(int p, int& pause, int& cnt) {
// Read an input packet from stdin and return it in p.
// The first argument on the line is assumed to be a pause
// specification that indicates how many seconds to wait
// before sending the packet. It may of course be 0.
// The pause value is returned on success.
// A negative value is returned on failure.
	ipa_t srcAdr; ipp_t srcPort;
	int leng, vnet, destAdr, x;
	string typStr;

	misc::skipBlank(cin);
	if (!misc::getNum(cin,pause) || !misc::getNum(cin,leng))
		return false;

	if (pause < 0) { cnt = leng; misc::cflush(cin,'\n'); return true; }

	if (!misc::getWord(cin,typStr) || 
	    !misc::getNum(cin,vnet) ||
	    !misc::getNum(cin,destAdr))
		return false;

	ps->setLeng(p,(uint16_t) leng);
	if (typStr == "data") ps->setPtyp(p,DATA);
	else if (typStr == "subscribe") ps->setPtyp(p,SUBSCRIBE);
	else if (typStr == "unsubscribe") ps->setPtyp(p,UNSUBSCRIBE);
	else return false;
	ps->setVnet(p,(vnet_t) vnet);
	ps->setSrcAdr(p,myAdr);
	ps->setDstAdr(p,destAdr);
	ps->pack(p);

	uint32_t* bp4 = (uint32_t*) ps->buffer(p);
	for (int i = 4; i < (leng+3)/4; i++) {
		if (misc::getNum(cin,x)) {
			bp4[i] = htonl(x);
		} else {
			bp4[i] = 0;
		}
	}
	misc::cflush(cin,'\n');
	return true;
}

int wuHost::receive() { 
// Return next waiting packet or Null if there is none. 
	int nbytes;	  // number of bytes in received packet
	sockaddr_in ssa;  // socket address of sender
	socklen_t ssaLen; // length of sender's socket address structure
	int lnk;	  // # of link on which packet received
	ipa_t sIpAdr; ipp_t sPort;

	int p = ps->alloc();
	if (p == Null) return Null;
	buffer_t* bp = ps->buffer(p);

	ssaLen = sizeof(ssa); 
	nbytes = recvfrom(sock, bp, 1500, 0,
	 	 	  (struct sockaddr *) &ssa, &ssaLen);
	if (nbytes < 0) {
		if (errno == EWOULDBLOCK) {
			ps->free(p); return Null;
		}
		fatal("wuHost::receive: error in recvfrom call");
	}
	return p;
}

void wuHost::send(int p) {
// Send packet on specified link and recycle storage.
	dsa.sin_addr.s_addr = htonl(rtrIpAdr);
	dsa.sin_port = htons(WUNET_PORT);
	int rv = sendto(sock,(void *) ps->buffer(p),ps->leng(p),0,
		    	(struct sockaddr *) &dsa, sizeof(dsa));
	if (rv == -1) fatal("wuHost::send: failure in sendto");
}

void wuHost::run(bool repeatFlag, uint32_t delta, uint32_t finishTime) {
// Run the host. If repeatFlag is true, then all packets after
// the first are repeated until finishTime. Delta is the minimum
// time between packets. FinishTime and delta are expressed in microseconds.
// The first packet is assumed to be a dummy packet whose only purpose
// is to allow the router to initialize the host's port number.
// A 1 second pause is inserted before and after the first packet.
	int i, pause, cnt, p, np;
	struct { int pause, p, cnt, iter; } pkt[nPkts+1];
	struct timeval ct, pt; // current and previous time values
	uint32_t now, then;    // free-running microsecond counts
	uint32_t nextTime;
	// read packets from file into packetStore
	np = 0;
	while (np < nPkts) {
		p = ps->alloc();
		if (p == Null) fatal("wuHost::run: too many packets");
		if (!getPacket(p,pause,cnt)) break;
		pkt[np].pause = pause;
		if (pause >= 0) {
			pkt[np++].p = p;
		} else {
			pkt[np].cnt = cnt; pkt[np++].iter = 0;
			ps->free(p);
		}
	}
	if (np == 0 || pkt[0].pause < 0) return;
	if (repeatFlag) { // setup infinite repeat
		pkt[np].pause = -(np-1);
		pkt[np++].cnt = 0;
	}
	// main loop
	if (gettimeofday(&ct,Null) < 0)
		fatal("wuHost::run: gettimeofday failure");
	i = 0; now = 0; nextTime = 1000000;
	while (now <= finishTime) {
		if (i < np && now >= nextTime) {
			send(pkt[i].p);
			if (i == 0) nextTime += 1000000;
			i++;
			while (i < np && pkt[i].pause < 0) { // repeat spec
				if (pkt[i].cnt <= 0) { // repeat forever
					i = max(1,i+pkt[i].pause);
				} else if (pkt[i].iter <= 0) {
					pkt[i].iter = pkt[i].cnt;
					i = max(1,i+pkt[i].pause);
				} else {
					pkt[i].iter -= 1;
					if (pkt[i].iter > 0)
						i = max(1,i+pkt[i].pause);
					else
						i++;
				}
			}
			if (i < np) nextTime += max(delta,pkt[i].pause);
		}
		pt = ct;
		if (gettimeofday(&ct,Null) < 0)
			fatal("wuHost::run: gettimeofday failure");
		now += (ct.tv_sec == pt.tv_sec ?
                           ct.tv_usec - pt.tv_usec :
                           ct.tv_usec + (1000000 - pt.tv_usec)
			);
	}

	sleep(2); // wait for arriving packets, then print 50
	for (i = 0; i < 50 && (p = receive()) != Null; i++) {
		ps->unpack(p);
		ps->print(cout,p); cout << endl;
		ps->free(p);
	}
}
