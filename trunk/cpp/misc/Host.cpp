/** @file Host.cpp 
 *
 *  @author Jon Turner
 *  @date 2011
 *  This is open source software licensed under the Apache 2.0 license.
 *  See http://www.apache.org/licenses/LICENSE-2.0 for details.
 */

#include "stdinc.h"
#include "Host.h"

using namespace forest;

/**
 *  usage:
 *       Host myIpAdr rtrIpAdr repeatFlag delta finTime
 * 
 *  Host is a simple packet generator for a forest host.
 *  MyIpAdr and rtrIpAdr are the IP addresses of the host itself
 *  and the forest router it connects to. If repeatFlag is false
 *  repeat specifications in the packet specification file are
 *  ignored. Delta is the minimum number of microseconds
 *  between successive packet transmissions.
 *  FinTime is the number of seconds that the host should run.
 * 
 *  The packets generated by Host are determined by a packet
 *  specification that is read from stdin. The input may include
 *  comment lines (which begin with '#'). Each non-blank, non-comment
 *  line specifies one packet in the form of a list of integer values
 *  separated by blanks. The first value on each line is a
 *  pause specification that indicates the number of microseconds
 *  to wait before sending the packet. This is ignored if it is
 *  less than delta. The next four values specify the packet's
 *  length (in bytes), its comtree number, the source forest address,
 *  and destination forest address.
 *  The remaining values on the line are interpreted as the values
 *  of successive payload words. If the number of specified values
 *  is not sufficient for the specified packet length, remaining
 *  payload words are zero-padded.
 * 
 *  A line with a negative number in the first field is treated
 *  as a repeat specification. If the value is -k, it goes back
 *  to the k-th previous non-comment line and continues from there. The
 *  number of repetitions is determined by the second value on
 *  the line containing the repeat specification. Repeat spec's
 *  can be combined and may be used to form nested loops. They
 *  can also be overlapped in more general ways, but the results
 *  are not likely to be useful.
 * 
 *  If repeatFlag=0, Host sends each of the listed packets one time,
 *  ignoring all repeat specifications.
 * 
 *  Host also receives incoming packets from its attached router.
 *  It saves the first 50 of these and writes them to stdout
 *  at the end of execution. This is done as a basic debugging aid.
 */
int main(int argc, char *argv[]) {
	ipa_t myIpAdr, rtrIpAdr;
	int repeatFlag, delta, finTime;

	if (argc != 6 ||
	    (myIpAdr = Np4d::ipAddress(argv[1])) == 0 ||
	    (rtrIpAdr = Np4d::ipAddress(argv[2])) == 0 ||
	    sscanf(argv[3],"%d", &repeatFlag) != 1 ||
	    sscanf(argv[4],"%d", &delta) != 1 ||
	    sscanf(argv[5],"%d", &finTime) != 1) {
		Util::fatal("usage: fHost myIpAdr routerIpAdr repeatCnt "
		      "delta finTime");
		exit(0); // redundant, but makes compiler happy
	}

	Host host(myIpAdr,rtrIpAdr);
	if (!host.init()) Util::fatal("Host:: initialization failure");
	host.run((repeatFlag ? true : false), delta, 1000000*finTime);
}

namespace forest {

// Constructor for Host, allocates space and initializes private data
Host::Host(ipa_t mipa, ipa_t ripa) : myIpAdr(mipa) , rtrIpAdr(ripa) {
	nPkts = 10000;
	ps = new PacketStore(nPkts+1, nPkts+1);
}

Host::~Host() { delete ps; }

/** Initialize IO. Return true on success, false on failure.
 *  Configure socket for non-blocking access, so that we don't
 *  block when there are no input packets available.
 */
bool Host::init() {
	sock = Np4d::datagramSocket();

	return  sock >= 0 &&
        	Np4d::bind4d(sock, myIpAdr, 0) &&
		Np4d::nonblock(sock);
}

void Host::run(bool repeatFlag, int delta, int finishTime) {
// Run the host. If repeatFlag is false, then all repeat specifications
// are ignored. Delta is the minimum time between packets.
// FinishTime and delta are expressed in microseconds.

	int i, pause, cnt, np;
	pktx px;
	const int MAXEVENTS = 200;
	struct { bool sendFlag; uint32_t time; int pkt;} events[MAXEVENTS];
	int evCnt = 0;
	int nRcvd = 0; int nSent = 0; 	// counts of received and sent packets
	bool didNothing;
	struct { int pause, p, cnt, iter; } pkt[nPkts+1];

	// read packets from file into packetStore
	np = 0;
	while (np < nPkts) {
		px = ps->alloc();
		if (px == 0) Util::fatal("Host::run: too many packets");
		if (!readPacket(px,pause,cnt)) break;
		pkt[np].pause = pause;
		if (pause >= 0) {
			pkt[np++].p = px;
		} else if (repeatFlag) {
			if (pause + np < 0) pause = -np;
			pkt[np].cnt = cnt; pkt[np++].iter = cnt;
			ps->free(px);
		} else {
			ps->free(px);
		}
	}
	if (np == 0) return;

	uint32_t now;    	// free-running microsecond count
	uint32_t nextTime;	// time next packet is to go out
	struct timeval ct, pt; // current and previous time values
	if (gettimeofday(&ct, NULL) < 0)
		Util::fatal("Host::run: gettimeofday failure");
	i = 0;	// index in pkt[] of next outgoing packet
	now = 0; nextTime = 1000000;
	while (now <= finishTime) {
		// receive packet if any and record statistics
		didNothing = true;
		// input processing
		px = receive();
		Packet& p = ps->getPacket(px);
		if (px != 0) {
			didNothing = false;
			nRcvd++;
			p.unpack();
			if (evCnt < MAXEVENTS) {
				events[evCnt].sendFlag = false;
				events[evCnt].time = now;
				events[evCnt].pkt = px;
				evCnt++;
			} else {
				ps->free(px);
			}
		}

		// send next packet
		if (i < np && now >= nextTime) {
			send(pkt[i].p);
			didNothing = false;
			nSent++;
			if (evCnt < MAXEVENTS) {
				pktx px1 = ps->clone(pkt[i].p);
				events[evCnt].sendFlag = true;
				events[evCnt].time = now;
				events[evCnt].pkt = px1;
				evCnt++;
			}
			i++;
			while (i < np && pkt[i].pause < 0) { // repeat spec
				if (pkt[i].cnt <= 0) { // repeat forever
					i += pkt[i].pause;
				} else if (pkt[i].iter <= 0) {
					pkt[i].iter = pkt[i].cnt;
					i += 1;
				} else {
					pkt[i].iter -= 1;
					i += pkt[i].pause;
				}
			}
			if (i < np) nextTime += std::max(delta,pkt[i].pause);
		}
		// update time variables
		pt = ct;
		if (gettimeofday(&ct,0) < 0)
			Util::fatal("Host::run: gettimeofday failure");
		now += (ct.tv_sec == pt.tv_sec ?
                           ct.tv_usec - pt.tv_usec :
                           ct.tv_usec + (1000000 - pt.tv_usec)
			);
		if (!didNothing) continue;

		// if next packet not due to go soon, sleep until almost time
		if (now + 500 >= nextTime) continue;
		struct timespec sleeptime, rem;
		sleeptime.tv_sec = 0;
		if (nextTime - (now + 500) < 2500)
			sleeptime.tv_nsec = (nextTime - (now + 500))*1000;
		else
			sleeptime.tv_nsec = 2500000;
		nanosleep(&sleeptime,&rem);
		// update time variables again following sleep
		pt = ct;
		if (gettimeofday(&ct,0) < 0)
			Util::fatal("Host::run: gettimeofday failure");
		now += (ct.tv_sec == pt.tv_sec ?
                           ct.tv_usec - pt.tv_usec :
                           ct.tv_usec + (1000000 - pt.tv_usec)
			);
	}

	// print recorded events
	for (int i = 0; i < evCnt; i++) {
		if (events[i].sendFlag) 
			cout << "send[";
		else
			cout << "recv[";
		cout << setw(2) << setw(8) << events[i].time << "] ";
		px = events[i].pkt;
		Packet& p = ps->getPacket(px);
		cout << p.toString();
	}
	cout << endl;
	cout << nRcvd << " packets received, " << nSent << " packets sent, "; 
}

bool Host::readPacket(pktx px, int& pause, int& cnt) {
// Read an input packet from stdin and return it in p.
        Util::skipBlank(cin);
        if (!Util::readInt(cin,pause)) return false;
        if (pause < 0) {
                if (!Util::readInt(cin,cnt)) cnt = 0;
                Util::nextLine(cin);
                return true;
        }
        Packet& p = ps->getPacket(px);
        bool success = p.read(cin);
        Util::nextLine(cin);
        return success;
}

void Host::send(pktx px) {
// Send packet and recycle storage.
	Packet& p = ps->getPacket(px);
	int rv = Np4d::sendto4d(sock,(void *) p.buffer, p.length,
		    		rtrIpAdr, Forest::ROUTER_PORT);
	if (rv == -1) Util::fatal("Host::send: failure in sendto");
}

int Host::receive() { 
// Return next waiting packet or 0 if there is none. 
	int nbytes;	  // number of bytes in received packet

	pktx px = ps->alloc();
	if (px == 0) return 0;
	Packet& p = ps->getPacket(px);

	ipa_t remoteIp; ipp_t remotePort;
        nbytes = Np4d::recvfrom4d(sock, p.buffer, 1500,
                          	  remoteIp, remotePort);
        if (nbytes < 0) {
                if (errno == EWOULDBLOCK) {
                        ps->free(px); return 0;
                }
                Util::fatal("Host::receive: error in recvfrom call");
        }

        p.bufferLen = nbytes;
        p.tunIp = remoteIp;
        p.tunPort = remotePort;

        return px;
}

} // ends namespace

