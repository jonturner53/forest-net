// usage:
//      fHost myIpAdr rtrIpAdr repeatFlag delta finTime
//
// FHost is a simple packet generator for a forest host.
// MyIpAdr and rtrIpAdr are the IP addresses of the host itself
// and the forest router it connects to. MyAdr is the forest adress
// of the host. Delta is the minimum number of microseconds
// between successive packet transmissions.
// FinTime is the number of seconds that the host should run.
//
// The packets generated by fHost are determined by a packet
// specification that is read from stdin. The input may include
// comment lines (which begin with '#'). Each non-blank, non-comment
// line specifies one packet in the form of a list of integer values
// separated by blanks. The first value on each line is a
// pause specification that indicates the number of microseconds
// to wait before sending the packet. This is ignored if it is
// less than delta. The next three values specify the packet's
// length (in bytes), its comtree number and destination forest address.
// The remaining values on the line are interpreted as the values
// of successive payload words. If the number of specified values
// is not sufficient for the specified packet length, remaining
// payload words are zero-padded.
//
// A line with a negative number in the first field is treated
// as a repeat specification. If the value is -k, it goes back
// to the k-th previous non-comment line and continues from there. The
// number of repetitions is determined by the second value on
// the line containing the repeat specification. Repeat spec's
// can be combined and may be used to form nested loops. They
// can also be overlapped in more general ways, but the results
// are not likely to be useful.
//
// If repeatFlag=0, fHost sends each of the listed packets one time,
// ignoring all repeat specifications.
//
// FHost also receives incoming packets from its attached router.
// It saves the first 50 of these and writes them to stdout
// at the end of execution. This is done as a basic debugging aid.

#include "stdinc.h"
#include "forest.h"
#include "fHost.h"

main(int argc, char *argv[]) {
	int mip0, mip1, mip2, mip3, rip0, rip1, rip2, rip3;
	ipa_t myIpAdr, rtrIpAdr;
	int repeatFlag, delta, finTime;

	if (argc != 6 ||
	    sscanf(argv[1],"%d.%d.%d.%d", &mip3, &mip2, &mip1, &mip0) != 4 ||
	    sscanf(argv[2],"%d.%d.%d.%d", &rip3, &rip2, &rip1, &rip0) != 4 ||
	    sscanf(argv[3],"%d", &repeatFlag) != 1 ||
	    sscanf(argv[4],"%d", &delta) != 1 ||
	    sscanf(argv[5],"%d", &finTime) != 1)
		fatal("usage: fHost myIpAdr routerIpAdr repeatCnt delta finTime");

	 myIpAdr = ((mip3 & 0xff) << 24)  | ((mip2 & 0xff) << 16) |
	           ((mip1 & 0xff) <<  8)  |  (mip0 & 0xff);
	rtrIpAdr = ((rip3 & 0xff) << 24)  | ((rip2 & 0xff) << 16) |
	           ((rip1 & 0xff) <<  8)  |  (rip0 & 0xff);

	fHost host(myIpAdr,rtrIpAdr);
	if (!host.init()) fatal("fHost:: initialization failure");
	host.run((repeatFlag ? true : false), delta, 1000000*finTime);
}


// Constructor for fHost, allocates space and initializes private data
fHost::fHost(ipa_t mipa, ipa_t ripa) : myIpAdr(mipa) , rtrIpAdr(ripa) {
	nPkts = 10000;
	ps = new pktStore(nPkts+1, nPkts+1);

	// initialize socket address structures
	bzero(&sa, sizeof(sa));
	sa.sin_family = AF_INET;
	sa.sin_port = 0; // let system select address
	sa.sin_addr.s_addr = htonl(myIpAdr);
	bzero(&dsa, sizeof(dsa));
	dsa.sin_family = AF_INET;
}

fHost::~fHost() { delete ps; }

bool fHost::init() {
// Initialize IO. Return true on success, false on failure.
// Configure socket for non-blocking access, so that we don't
// block when there are no input packets available.
	// create datagram socket
	if ((sock = socket(AF_INET, SOCK_DGRAM, 0)) < 0) {
                return false;
        }
	// bind it to the socket address structure
        if (bind(sock, (struct sockaddr *) &sa, sizeof(sa)) < 0) {
                return false;
        }
	// make socket nonblocking
	int flags;
	if ((flags = fcntl(sock, F_GETFL, 0)) < 0)
		return false;
	flags |= O_NONBLOCK;
	if ((flags = fcntl(sock, F_SETFL, flags)) < 0)
		return false;
	return true;
}

bool fHost::getPacket(packet p, int& pause, int& cnt) {
// Read an input packet from stdin and return it in p.
        misc::skipBlank(cin);
        if (!misc::getNum(cin,pause)) return false;
        if (pause < 0) {
                if (!misc::getNum(cin,cnt)) cnt = 0;
                misc::cflush(cin,'\n');
                return true;
        }
        header& h = ps->hdr(p);
        bool success = h.getPacket(cin,ps->buffer(p));
        misc::cflush(cin,'\n');
        return success;
}

int fHost::receive() { 
// Return next waiting packet or Null if there is none. 
	int nbytes;	  // number of bytes in received packet
	sockaddr_in ssa;  // socket address of sender
	socklen_t ssaLen; // length of sender's socket address structure
	int lnk;	  // # of link on which packet received
	ipa_t sIpAdr; ipp_t sPort;

	int p = ps->alloc();
	if (p == Null) return Null;
	header& h = ps->hdr(p);
        buffer_t& b = ps->buffer(p);

        ssaLen = sizeof(ssa); 
        nbytes = recvfrom(sock, &b[0], 1500, 0,
                          (struct sockaddr *) &ssa, &ssaLen);
        if (nbytes < 0) {
                if (errno == EWOULDBLOCK) {
                        ps->free(p); return Null;
                }
                fatal("fHost::receive: error in recvfrom call");
        }

        h.ioBytes() = nbytes;
        h.tunSrcIp() = ntohl(ssa.sin_addr.s_addr);
        h.tunSrcPort() = ntohs(ssa.sin_port);

        return p;
}

void fHost::send(int p) {
// Send packet on specified link and recycle storage.
	dsa.sin_addr.s_addr = htonl(rtrIpAdr);
	dsa.sin_port = htons(FOREST_PORT);
	header& h = ps->hdr(p);
	int rv = sendto(sock,(void *) ps->buffer(p),h.leng(),0,
		    	(struct sockaddr *) &dsa, sizeof(dsa));
	if (rv == -1) fatal("fHost::send: failure in sendto");
}

void fHost::run(bool repeatFlag, uint32_t delta, uint32_t finishTime) {
// Run the host. If repeatFlag is false, then all repeat specifications
// are ignored. Delta is the minimum time between packets.
// FinishTime and delta are expressed in microseconds.

	int i, pause, cnt, p, np;
	const int MAXEVENTS = 200;
	struct { bool sendFlag; uint32_t time; int pkt;} events[MAXEVENTS];
	int evCnt = 0;
	int nRcvd = 0; int nSent = 0; 	// counts of received and sent packets
	int discards = 0;		// count of number discards
	int statsTime = 0;		// time statistics were last processed
	bool didNothing;
	struct { int pause, p, cnt, iter; } pkt[nPkts+1];

	// read packets from file into packetStore
	np = 0;
	while (np < nPkts) {
		p = ps->alloc();
		if (p == Null) fatal("fHost::run: too many packets");
		if (!getPacket(p,pause,cnt)) break;
		pkt[np].pause = pause;
		if (pause >= 0) {
			pkt[np++].p = p;
		} else if (repeatFlag) {
			if (pause + np < 0) pause = -np;
			pkt[np].cnt = cnt; pkt[np++].iter = cnt;
			ps->free(p);
		} else {
			ps->free(p);
		}
	}
	if (np == 0) return;

	uint32_t now;    	// free-running microsecond count
	uint32_t nextTime;	// time next packet is to go out
	struct timeval ct, pt; // current and previous time values
	if (gettimeofday(&ct, NULL) < 0)
		fatal("fHost::run: gettimeofday failure");
	i = 0;	// index in pkt[] of next outgoing packet
	now = 0; nextTime = 1000000;
	while (now <= finishTime) {
		// receive packet if any and record statistics
		didNothing = true;
		// input processing
		p = receive();
		if (p != Null) {
			didNothing = false;
			nRcvd++;
			ps->unpack(p);
			if (evCnt < MAXEVENTS) {
				events[evCnt].sendFlag = false;
				events[evCnt].time = now;
				events[evCnt].pkt = p;
				evCnt++;
			} else {
				ps->free(p);
			}
		}

		// send next packet
		if (i < np && now >= nextTime) {
			send(pkt[i].p);
			didNothing = false;
			nSent++;
			if (evCnt < MAXEVENTS) {
				int p1 = ps->clone(pkt[i].p);
				events[evCnt].sendFlag = true;
				events[evCnt].time = now;
				events[evCnt].pkt = p1;
				evCnt++;
			}
			i++;
			while (i < np && pkt[i].pause < 0) { // repeat spec
				if (pkt[i].cnt <= 0) { // repeat forever
					i += pkt[i].pause;
				} else if (pkt[i].iter <= 0) {
					pkt[i].iter = pkt[i].cnt;
					i += 1;
				} else {
					pkt[i].iter -= 1;
					i += pkt[i].pause;
				}
			}
			if (i < np) nextTime += max(delta,pkt[i].pause);
		}
		// update time variables
		pt = ct;
		if (gettimeofday(&ct,Null) < 0)
			fatal("fHost::run: gettimeofday failure");
		now += (ct.tv_sec == pt.tv_sec ?
                           ct.tv_usec - pt.tv_usec :
                           ct.tv_usec + (1000000 - pt.tv_usec)
			);
		if (!didNothing) continue;

		// if next packet not due to go soon, sleep until almost time
		if (now + 500 >= nextTime) continue;
		struct timespec sleeptime, rem;
		sleeptime.tv_sec = 0;
		if (nextTime - (now + 500) < 2500)
			sleeptime.tv_nsec = (nextTime - (now + 500))*1000;
		else
			sleeptime.tv_nsec = 2500000;
		nanosleep(&sleeptime,&rem);
		// update time variables again following sleep
		pt = ct;
		if (gettimeofday(&ct,Null) < 0)
			fatal("fHost::run: gettimeofday failure");
		now += (ct.tv_sec == pt.tv_sec ?
                           ct.tv_usec - pt.tv_usec :
                           ct.tv_usec + (1000000 - pt.tv_usec)
			);
	}

	// print recorded events
	for (int i = 0; i < evCnt; i++) {
		if (events[i].sendFlag) 
			cout << "send[";
		else
			cout << "recv[";
		cout << setw(2) << setw(8) << events[i].time << "] ";
		p = events[i].pkt; header& h = ps->hdr(p);
		h.print(cout,ps->buffer(p));
	}
	cout << endl;
	cout << nRcvd << " packets received, " << nSent << " packets sent, "; 
}
