/** \file Host.cpp */

#include "stdinc.h"
#include "Host.h"

/**
 *  usage:
 *       fHost myIpAdr rtrIpAdr repeatFlag delta finTime
 * 
 *  FHost is a simple packet generator for a forest host.
 *  MyIpAdr and rtrIpAdr are the IP addresses of the host itself
 *  and the forest router it connects to. MyAdr is the forest adress
 *  of the host. Delta is the minimum number of microseconds
 *  between successive packet transmissions.
 *  FinTime is the number of seconds that the host should run.
 * 
 *  The packets generated by Host are determined by a packet
 *  specification that is read from stdin. The input may include
 *  comment lines (which begin with '#'). Each non-blank, non-comment
 *  line specifies one packet in the form of a list of integer values
 *  separated by blanks. The first value on each line is a
 *  pause specification that indicates the number of microseconds
 *  to wait before sending the packet. This is ignored if it is
 *  less than delta. The next three values specify the packet's
 *  length (in bytes), its comtree number and destination forest address.
 *  The remaining values on the line are interpreted as the values
 *  of successive payload words. If the number of specified values
 *  is not sufficient for the specified packet length, remaining
 *  payload words are zero-padded.
 * 
 *  A line with a negative number in the first field is treated
 *  as a repeat specification. If the value is -k, it goes back
 *  to the k-th previous non-comment line and continues from there. The
 *  number of repetitions is determined by the second value on
 *  the line containing the repeat specification. Repeat spec's
 *  can be combined and may be used to form nested loops. They
 *  can also be overlapped in more general ways, but the results
 *  are not likely to be useful.
 * 
 *  If repeatFlag=0, Host sends each of the listed packets one time,
 *  ignoring all repeat specifications.
 * 
 *  FHost also receives incoming packets from its attached router.
 *  It saves the first 50 of these and writes them to stdout
 *  at the end of execution. This is done as a basic debugging aid.
 */
main(int argc, char *argv[]) {
	int mip0, mip1, mip2, mip3, rip0, rip1, rip2, rip3;
	ipa_t myIpAdr, rtrIpAdr;
	int repeatFlag, delta, finTime;

	if (argc != 6 ||
	    (myIpAdr = Np4d::ipAddress(argv[1])) == 0 ||
	    (rtrIpAdr = Np4d::ipAddress(argv[2])) == 0 ||
	    sscanf(argv[3],"%d", &repeatFlag) != 1 ||
	    sscanf(argv[4],"%d", &delta) != 1 ||
	    sscanf(argv[5],"%d", &finTime) != 1)
		fatal("usage: fHost myIpAdr routerIpAdr repeatCnt "
		      "delta finTime");

	Host host(myIpAdr,rtrIpAdr);
	if (!host.init()) fatal("Host:: initialization failure");
	host.run((repeatFlag ? true : false), delta, 1000000*finTime);
}

// Constructor for Host, allocates space and initializes private data
Host::Host(ipa_t mipa, ipa_t ripa) : myIpAdr(mipa) , rtrIpAdr(ripa) {
	nPkts = 10000;
	ps = new PacketStore(nPkts+1, nPkts+1);

	// initialize socket address structures
	bzero(&sa, sizeof(sa));
	sa.sin_family = AF_INET;
	sa.sin_port = 0; // let system select address
	sa.sin_addr.s_addr = htonl(myIpAdr);
	bzero(&dsa, sizeof(dsa));
	dsa.sin_family = AF_INET;
}

Host::~Host() { delete ps; }

bool Host::init() {
// Initialize IO. Return true on success, false on failure.
// Configure socket for non-blocking access, so that we don't
// block when there are no input packets available.
	// create datagram socket
	if ((sock = socket(AF_INET, SOCK_DGRAM, 0)) < 0) {
                return false;
        }
	// bind it to the socket address structure
        if (bind(sock, (struct sockaddr *) &sa, sizeof(sa)) < 0) {
                return false;
        }
	// make socket nonblocking
	int flags;
	if ((flags = fcntl(sock, F_GETFL, 0)) < 0)
		return false;
	flags |= O_NONBLOCK;
	if ((flags = fcntl(sock, F_SETFL, flags)) < 0)
		return false;
	return true;
}
void Host::run(bool repeatFlag, uint32_t delta, uint32_t finishTime) {
// Run the host. If repeatFlag is false, then all repeat specifications
// are ignored. Delta is the minimum time between packets.
// FinishTime and delta are expressed in microseconds.

	int i, pause, cnt, p, np;
	const int MAXEVENTS = 200;
	struct { bool sendFlag; uint32_t time; int pkt;} events[MAXEVENTS];
	int evCnt = 0;
	int nRcvd = 0; int nSent = 0; 	// counts of received and sent packets
	int discards = 0;		// count of number discards
	int statsTime = 0;		// time statistics were last processed
	bool didNothing;
	struct { int pause, p, cnt, iter; } pkt[nPkts+1];

	// read packets from file into packetStore
	np = 0;
	while (np < nPkts) {
		p = ps->alloc();
		if (p == Null) fatal("Host::run: too many packets");
		if (!readPacket(p,pause,cnt)) break;
		pkt[np].pause = pause;
		if (pause >= 0) {
			pkt[np++].p = p;
		} else if (repeatFlag) {
			if (pause + np < 0) pause = -np;
			pkt[np].cnt = cnt; pkt[np++].iter = cnt;
			ps->free(p);
		} else {
			ps->free(p);
		}
	}
	if (np == 0) return;

	uint32_t now;    	// free-running microsecond count
	uint32_t nextTime;	// time next packet is to go out
	struct timeval ct, pt; // current and previous time values
	if (gettimeofday(&ct, NULL) < 0)
		fatal("Host::run: gettimeofday failure");
	i = 0;	// index in pkt[] of next outgoing packet
	now = 0; nextTime = 1000000;
	while (now <= finishTime) {
		// receive packet if any and record statistics
		didNothing = true;
		// input processing
		p = receive();
		if (p != Null) {
			didNothing = false;
			nRcvd++;
			ps->unpack(p);
			if (evCnt < MAXEVENTS) {
				events[evCnt].sendFlag = false;
				events[evCnt].time = now;
				events[evCnt].pkt = p;
				evCnt++;
			} else {
				ps->free(p);
			}
		}

		// send next packet
		if (i < np && now >= nextTime) {
			send(pkt[i].p);
			didNothing = false;
			nSent++;
			if (evCnt < MAXEVENTS) {
				int p1 = ps->clone(pkt[i].p);
				events[evCnt].sendFlag = true;
				events[evCnt].time = now;
				events[evCnt].pkt = p1;
				evCnt++;
			}
			i++;
			while (i < np && pkt[i].pause < 0) { // repeat spec
				if (pkt[i].cnt <= 0) { // repeat forever
					i += pkt[i].pause;
				} else if (pkt[i].iter <= 0) {
					pkt[i].iter = pkt[i].cnt;
					i += 1;
				} else {
					pkt[i].iter -= 1;
					i += pkt[i].pause;
				}
			}
			if (i < np) nextTime += max(delta,pkt[i].pause);
		}
		// update time variables
		pt = ct;
		if (gettimeofday(&ct,Null) < 0)
			fatal("Host::run: gettimeofday failure");
		now += (ct.tv_sec == pt.tv_sec ?
                           ct.tv_usec - pt.tv_usec :
                           ct.tv_usec + (1000000 - pt.tv_usec)
			);
		if (!didNothing) continue;

		// if next packet not due to go soon, sleep until almost time
		if (now + 500 >= nextTime) continue;
		struct timespec sleeptime, rem;
		sleeptime.tv_sec = 0;
		if (nextTime - (now + 500) < 2500)
			sleeptime.tv_nsec = (nextTime - (now + 500))*1000;
		else
			sleeptime.tv_nsec = 2500000;
		nanosleep(&sleeptime,&rem);
		// update time variables again following sleep
		pt = ct;
		if (gettimeofday(&ct,Null) < 0)
			fatal("Host::run: gettimeofday failure");
		now += (ct.tv_sec == pt.tv_sec ?
                           ct.tv_usec - pt.tv_usec :
                           ct.tv_usec + (1000000 - pt.tv_usec)
			);
	}

	// print recorded events
	for (int i = 0; i < evCnt; i++) {
		if (events[i].sendFlag) 
			cout << "send[";
		else
			cout << "recv[";
		cout << setw(2) << setw(8) << events[i].time << "] ";
		p = events[i].pkt;
		ps->getHeader(p).write(cout,ps->getBuffer(p));
	}
	cout << endl;
	cout << nRcvd << " packets received, " << nSent << " packets sent, "; 
}

bool Host::readPacket(packet p, int& pause, int& cnt) {
// Read an input packet from stdin and return it in p.
        Misc::skipBlank(cin);
        if (!Misc::readNum(cin,pause)) return false;
        if (pause < 0) {
                if (!Misc::readNum(cin,cnt)) cnt = 0;
                Misc::cflush(cin,'\n');
                return true;
        }
        PacketHeader& h = ps->getHeader(p);
        bool success = h.read(cin,ps->getBuffer(p));
        Misc::cflush(cin,'\n');
        return success;
}

void Host::send(int p) {
// Send packet and recycle storage.
	int length = ps->getHeader(p).getLength();
	int rv = Np4d::sendto4d(sock,(void *) ps->getBuffer(p),length,
		    		rtrIpAdr, Forest::ROUTER_PORT);
	if (rv == -1) fatal("Host::send: failure in sendto");
}

int Host::receive() { 
// Return next waiting packet or Null if there is none. 
	int nbytes;	  // number of bytes in received packet
	int lnk;	  // # of link on which packet received

	int p = ps->alloc();
	if (p == Null) return Null;
	PacketHeader& h = ps->getHeader(p);
        buffer_t& b = ps->getBuffer(p);

	ipa_t remoteIp; ipp_t remotePort;
        nbytes = Np4d::recvfrom4d(sock, &b[0], 1500,
                          	  remoteIp, remotePort);
        if (nbytes < 0) {
                if (errno == EWOULDBLOCK) {
                        ps->free(p); return Null;
                }
                fatal("Host::receive: error in recvfrom call");
        }

        h.setIoBytes(nbytes);
        h.setTunSrcIp(remoteIp);
        h.setTunSrcPort(remotePort);

        return p;
}
